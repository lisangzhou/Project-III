/* Kruskal.java */

import graph.*;
import set.*;
import dict.*;
import java.util.Random;
import list.*;

/**
 * The Kruskal class contains the method minSpanTree(), which implements
 * Kruskal's algorithm for computing a minimum spanning tree of a graph.
 */

public class Kruskal {

  /**
   * minSpanTree() returns a WUGraph that represents the minimum spanning tree
   * of the WUGraph g.  The original WUGraph g is NOT changed.
   */
  public static WUGraph minSpanTree(WUGraph g){
    WUGraph minSpanningGraph = new WUGraph();
    DList allEdges = new DList();
    Object[] allVertices = g.getVertices();
    HashTableChained vertexMap = new HashTableChained(allVertices.length);
    DisjointSets vertexSet = new DisjointSets(allVertices.length);

    // get all of the edges. also create a map for vertices to indices in the disjoint set
    for(int j = 0; j < allVertices.length; j++){
      Object vertex = allVertices[j];

      vertexMap.insert(vertex,new Integer(j));
      
      Neighbors allNeighbors = g.getNeighbors(vertex);
      for(int i = 0; i < allNeighbors.neighborList.length; i++){
        allEdges.insertBack(new KruskalEdge(vertex,allNeighbors.neighborList[i],allNeighbors.weightList[i]));
      }
    }

    try{
      ListNode current = allEdges.front();
      for(int j = 0; j < allEdges.length(); j++){
        System.out.println(current.item() + " ");
        current = current.next();
      }
    } catch(InvalidNodeException error){}
    System.out.println(allEdges.length());
    allEdges = mergeSort(allEdges);
    System.out.println();
    try{
      ListNode current = allEdges.front();
      for(int j = 0; j < allEdges.length(); j++){
        System.out.println(current.item() + " ");
        current = current.next();
      }
    } catch(InvalidNodeException error){}
    System.out.println(allEdges.length());
    try{
      while(allEdges.length() > 0){
        KruskalEdge edge = (KruskalEdge) allEdges.front().item();
        Object first = edge.firstVertex();
        Object second = edge.secondVertex();
        int firstRoot = vertexSet.find(((Integer) vertexMap.find(first).value()).intValue());
        int secondRoot = vertexSet.find(((Integer) vertexMap.find(second).value()).intValue());
        if(!first.equals(second) && (firstRoot == -1 || secondRoot == -1 || firstRoot != secondRoot)){
          minSpanningGraph.addEdge(first,second,edge.weight());
          vertexSet.union(firstRoot,secondRoot);
        }
        allEdges.front().remove();
      }
    } catch(InvalidNodeException error){}

    return minSpanningGraph;
  }

  /**
    quickSort() sorts an array using in-place quicksort
    @param array is the array that is being sorted
    @param low is the lower index bound of the array being sorted. Inclusive
    @param high is the upper index bound of the array being sorted. Inclusive
  **/
  private static void quickSort(Comparable[] array, int low, int high){
    if(high - low >= 1){
      int pivotIndex = randomNumber(low,high);
      Comparable pivot = array[pivotIndex];
      array[pivotIndex] = array[high];
      array[high] = pivot;

      int i = low - 1;
      int j = high;
      do{
        do{i++; } while(array[i].compareTo(pivot) < 0);
        do{j--; } while(array[j].compareTo(pivot) > 0 && (j > low));

        if(i < j){
          Comparable ith = array[i];
          array[i] = array[j];
          array[j] = ith;
        }
      } while(i < j);
      
      array[high] = array[i];
      array[i] = pivot;
      quickSort(array,low,i-1);
      quickSort(array,i+1,high);
    }

  }

  private static DList mergeSort(DList list){
    if(list.length() <= 1){
      return list;
    } else{
      
      int targetElement = list.length() / 2;
      DList firstHalf = new DList();
      try{
        for(int i = 0; i < targetElement; i++){
          firstHalf.insertBack(list.front().item());
          list.front().remove();
        }
      } catch(InvalidNodeException error){}
      
      DList firstHalfSorted = mergeSort(firstHalf);
      DList secondHalfSorted = mergeSort(list);
      return merge(firstHalfSorted, secondHalfSorted);
    }
  }

  private static DList merge(DList one, DList two){
    DList solutionList = new DList();
    try{
      while(one.length() > 0 && two.length() > 0){
        Comparable oneFront = (Comparable) one.front().item();
        Comparable twoFront = (Comparable) two.front().item();
        if(oneFront.compareTo(twoFront) <= 0){
          solutionList.insertBack(oneFront);
          one.front().remove();
        } else{
          solutionList.insertBack(twoFront);
          two.front().remove();
        }
      }

      while(one.length() > 0){
        solutionList.insertBack(one.front().item());
        one.front().remove();
      }

      while(two.length() > 0){
        solutionList.insertBack(two.front().item());
        two.front().remove();
      }
    } catch(InvalidNodeException error){}
    return solutionList;
  }

  /**
    randomNumber() produces a random number between low and high, inclusive
    @param low is the lower bound for random number generation. The random number generated is an integer greater than or equal to this lower bound.
    @param high is the upper bound for random number generation. The random number generated is an integer less than or equal to this upper bound. high must be greater than
      low, otherwise behavior may be unexpected.
  **/
  private static int randomNumber(int low, int high){
    Random random = new Random();

    int r = random.nextInt();
    int randomValue = r % (high - low + 1);
    if(randomValue < 0){
      return low - randomValue;
    } else{
      return randomValue + low;
    }
  }


  public static void main(String[] args){
    DList tester = new DList();
    for(int i = 0; i < 40; i++){
      Integer a = new Integer(randomNumber(10,10000));
      tester.insertBack(a);
    }

    DList sorted = mergeSort(tester);
    try{
      for(int j = 0; j < 40; j++){
        System.out.print(sorted.front().item() + " ");
        sorted.front().remove();
      }
    } catch(InvalidNodeException error){}

    System.out.println();
  }
}
